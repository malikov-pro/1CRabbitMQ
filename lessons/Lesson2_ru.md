Руководство RabbitMQ - 2. Рабочие очереди (Work Queues)
  
_240926171204.png
_240927002737.png

> Перевод руководства и адаптация кода под платформу 1С.  
> Оригинал: https://www.rabbitmq.com/tutorials/tutorial-two-python

## Предпосылки
Как и в других руководствах по 1С, буду использовать компоненту kovalevdmv/1CRabbitMQ, интерфейс компоненты реализован через обработку `КлиентRMQ` (в составе конфигурации). Запускать consumer (потребителей) буду в фоновых заданиях в клиент-серверном варианте.

## На чем сосредоточено внимание в этом Руководстве
В первом руководстве мы написали программы для отправки и получения сообщений из именованной очереди. В этом руководстве мы создадим рабочую очередь, которая будет использоваться для распределения трудоемких задач между несколькими исполнителями (workers).

Основная идея рабочих очередей (Work Queues), также называемых очередями задач (Task Queues), заключается в том, чтобы избежать немедленного выполнения ресурсоемкой задачи и необходимости ждать ее завершения. Вместо этого мы планируем выполнение задачи позже. Мы инкапсулируем задачу в виде сообщения и отправляем его в очередь. Рабочий процесс, запущенный в фоновом режиме, выведет задачи на экран и в конечном итоге выполнит задание. При запуске большого количества рабочих процессов задачи будут распределены между ними.

Эта концепция особенно полезна в веб-приложениях, где невозможно выполнить сложную задачу за короткое время выполнения HTTP-запроса.

В предыдущей части этого урока мы отправили сообщение, содержащее "Hello World!". Теперь мы будем отправлять строки, обозначающие сложные задачи. У нас нет реальной задачи, такой как изменение размера изображений или рендеринг pdf-файлов, поэтому давайте имитируем, что клиентская часть занята, используя функцию `ОбщегоНазначенияБТС.Пауза(5)`.

### Отправка задач

Мы немного изменим код отправки из нашего предыдущего примера, чтобы разрешить отправку пакета сообщений.

```bsl
&НаСервере
Процедура ОтправкаСПараметром() Экспорт
	
	КлиентRMQ = Обработки.КлиентRMQ.Создать();
	СтрокаПодключения = "amqp://guest:guest@localhost:5672/%2f";
	Подключение = КлиентRMQ.ПодключитьсяКСерверу(СтрокаПодключения);
	
	Если КлиентRMQ.ЭтоОшибка(Подключение) Тогда
		Сообщить(Подключение.Текст);
		Возврат;
	КонецЕсли;
	
	Канал = КлиентRMQ.СоздатьКанал(Подключение);
	
	ИмяОчереди = "task_queue";
	// Объявляем durable очередь
	КлиентRMQ.ОбъявитьОчередь(Канал, ИмяОчереди, "", "", Истина);
	
	Данные = "Hello world!";
	
	Для Сч = 1 По 5 Цикл
		ОтправляемоеСообщение = Данные + " " + Сч;
		// Отправляем persistent сообщение в durable очередь
		Ответ = КлиентRMQ.ОпубликоватьСообщение(
			Канал, 
			ОтправляемоеСообщение, 
			ИмяОчереди,  // КлючМаршрутизации = имя очереди (default exchange)
			"",          // ТочкаОбмена = "" (default exchange)
			Истина,      // СериализоватьДанные
			Истина       // СохранитьСообщениеНаДиске (persistent)
		);
		Сообщить("Отправлено " + ОтправляемоеСообщение);
	КонецЦикла;
	
	КлиентRMQ.ОтключитьсяОтСервера(Подключение);
	
КонецПроцедуры
```

### Обработка задач

Наш старый скрипт обработки также требует некоторых изменений: ему нужно имитировать работу для каждого события.

```bsl
Пока КлиентRMQ.СледующееСообщение(Получатель) Цикл
	
	// получить данные сообщения
	ДанныеСообщения = КлиентRMQ.ДанныеСообщения();
	
	// Проверка на ошибки, если они возникли
	Если КлиентRMQ.ЭтоОшибка(ДанныеСообщения) Тогда
		Продолжить;   
	КонецЕсли; 

	Сообщить("Из очереди прочитано сообщение " + ДанныеСообщения.Данные);

	// Имитация работы (5 секунд)
	ОбщегоНазначенияБТС.Пауза(5);

	// подтвердить получение сообщения. После чего оно удалится из очереди.
	КлиентRMQ.ПодтвердитьСообщение(Канал, ДанныеСообщения.Тег);
	
КонецЦикла;
```

## Циклическая диспетчеризация
Одним из преимуществ использования очереди задач является возможность легко распараллеливать работу. Если мы накапливаем объем невыполненной работы, мы можем просто добавить больше исполнителей (workers) и таким образом легко масштабировать.

Сначала давайте попробуем запустить две функции получения и обработки одновременно. Они оба будут получать сообщения из очереди, но как именно? Давайте посмотрим.

Запускаем фоновые задания для каждого потребителя - C1 и C2

На клиенте мы запустим ОтправкаСПараметром(). Как только вы запустите группу потребителей, вы можете опубликовать несколько сообщений:

Отправлено Hello World! 1.
Отправлено Hello World! 2.
Отправлено Hello World! 3.
Отправлено Hello World! 4.
Отправлено Hello World! 5.
Давайте посмотрим, что доставляют нашим исполнителям:
 

Клиент 1

Из очереди прочитано сообщение Hello World! 1.
Из очереди прочитано сообщение Hello World! 3.
Из очереди прочитано сообщение Hello World! 5.

Клиент 2

Из очереди прочитано сообщение Hello World! 2.
Из очереди прочитано сообщение Hello World! 4.
 

По умолчанию RabbitMQ будет отправлять каждое сообщение следующему пользователю в определенной последовательности. В среднем каждый пользователь получит одинаковое количество сообщений. Такой способ распространения сообщений называется циклическим. Попробуйте его с тремя или более пользователями.

## Подтверждение сообщения
Выполнение задачи может занять несколько секунд, и вы можете задаться вопросом, что произойдет, если пользователь запустит длинную задачу, и она завершится до ее завершения. В нашем текущем коде, как только RabbitMQ доставит сообщение пользователю, оно сразу же удаляется из очереди. В этом случае, если вы завершаете работу потребителя, сообщение, которое он только что обрабатывал, теряется. Сообщения, которые были отправлены этому конкретному потребителю, но еще не были обработаны, также теряются.

Но мы не хотим терять ни одной задачи. Если потребитель умирает, мы бы хотели, чтобы задача была передана другому потребителю.

Чтобы гарантировать, что сообщение никогда не будет потеряно, RabbitMQ поддерживает подтверждение сообщений (message acknowledgments). Пользователь отправляет ответное подтверждение (ack), сообщающее RabbitMQ, что конкретное сообщение было получено, обработано и что RabbitMQ может его удалить. 

Если потребитель умирает (его канал закрыт, соединение прервано или TCP-соединение потеряно) без отправки подтверждения, RabbitMQ поймет, что сообщение не было обработано полностью, и повторно поместит его в очередь. Если в то же время в Сети есть другие потребители, система быстро переадресует его другому пользователю. Таким образом, вы можете быть уверены, что ни одно сообщение не будет потеряно, даже если потребители время от времени погибнут.

При подтверждении доставки потребителем устанавливается тайм-аут (по умолчанию 30 минут). Это помогает обнаруживать сбои в работе (зависание) потребителей, которые никогда не подтверждают доставку. Вы можете увеличить этот тайм-аут, как описано в разделе Тайм-аут подтверждения доставки.

Ручные подтверждения сообщений включены по умолчанию. В предыдущих примерах мы явно отключили их с помощью флага noConfirm = Истина;. Пришло время снять этот флаг и отправить соответствующее подтверждение от потребителя, как только мы закончим выполнение задачи.

&НаСервере
Процедура ПолучениеСЗадержкой() Экспорт
	
	Пока КлиентRMQ.СледующееСообщение(Получатель) Цикл
		ДанныеСообщения = КлиентRMQ.ДанныеСообщения();
		
		Если КлиентRMQ.ЭтоОшибка(ДанныеСообщения) Тогда
			Продолжить;
		КонецЕсли;
		
		Сообщить("Из очереди прочитано сообщение " + ДанныеСообщения.Данные);
		
		// Имитация работы (5 секунд)
		ОбщегоНазначенияБТС.Пауза(5);
		
		// Подтверждение получения сообщения
		КлиентRMQ.ПодтвердитьСообщение(Канал, ДанныеСообщения.Тег);
	КонецЦикла;
	
КонецПроцедуры


&НаСервере
Процедура ПолучениеСЗадержкойЦикл() Экспорт
	
	КлиентRMQ = Обработки.КлиентRMQ.Создать();
	СтрокаПодключения = "amqp://guest:guest@localhost:5672/%2f";
	Подключение = КлиентRMQ.ПодключитьсяКСерверу(СтрокаПодключения);
	
	Если КлиентRMQ.ЭтоОшибка(Подключение) Тогда
		Сообщить(Подключение.Текст);
		Возврат;
	КонецЕсли;
	
	// Создаем канал с QoS = 1 для справедливого распределения
	Канал = КлиентRMQ.СоздатьКанал(Подключение, Ложь, 1);
	
	ИмяОчереди = "task_queue";
	// Объявляем durable очередь
	КлиентRMQ.ОбъявитьОчередь(Канал, ИмяОчереди, "", "", Истина);
	
	// Создаем получателя с ручным подтверждением (no_ack = Ложь)
	Получатель = КлиентRMQ.СоздатьПолучателя(Канал, ИмяОчереди, "worker-1", Ложь);
	
	// Цикл обработки сообщений
	Пока КлиентRMQ.СледующееСообщение(Получатель) Цикл
		ДанныеСообщения = КлиентRMQ.ДанныеСообщения();
		
		Если КлиентRMQ.ЭтоОшибка(ДанныеСообщения) Тогда
			Продолжить;
		КонецЕсли;
		
		Сообщить("Из очереди прочитано сообщение " + ДанныеСообщения.Данные);
		
		// Имитация работы (5 секунд)
		Попытка
			ОбщегоНазначенияБТС.Пауза(5);
			
			// Подтвердить успешную обработку
			КлиентRMQ.ПодтвердитьСообщение(Канал, ДанныеСообщения.Тег);
		Исключение
			// При ошибке вернуть в очередь
			КлиентRMQ.ОтклонитьСообщение(Канал, ДанныеСообщения.Тег, Истина);
		КонецПопытки;
	КонецЦикла;
	
	КлиентRMQ.ОтключитьсяОтСервера(Подключение);
	
КонецПроцедуры
Используя этот код, вы можете гарантировать, что даже если вы завершите работу обработчика (worker) во время обработки сообщения, ничего не будет потеряно. Вскоре после завершения работы обработчика (worker) все неподтвержденные сообщения будут доставлены повторно.

Подтверждение должно быть отправлено по тому же каналу, по которому была получена доставка. Попытки подтверждения с использованием другого канала приведут к исключению протокола канального уровня.

## Долговечность сообщения
Мы научились делать так, чтобы даже в случае смерти потребителя задача не была потеряна. Но наши задачи все равно будут потеряны, если сервер RabbitMQ остановится.

Когда RabbitMQ завершает работу или выходит из строя, он забывает об очередях и сообщениях, если вы не скажете ему этого не делать. Чтобы убедиться, что сообщения не потеряны, необходимы две вещи: нам нужно пометить очередь и сообщения как долговременные.

Во-первых, нам нужно убедиться, что очередь выдержит перезапуск узла RabbitMQ. Для этого нам нужно объявить ее долговечной (durable):

```bsl
ИмяОчереди = "hello";
СохранятьОчередь = Истина; // durable
КлиентRMQ.ОбъявитьОчередь(Канал, ИмяОчереди, "", "", СохранятьОчередь);
```
Хотя сама по себе эта команда верна, в нашей настройке она работать не будет. Это потому, что мы уже определили очередь с именем hello, которая не является долговременной. RabbitMQ не позволяет вам переопределить существующую очередь с другими параметрами и вернет ошибку любой программе, которая попытается это сделать. Но есть быстрый обходной путь - давайте объявим очередь с другим именем, например task_queue:

```bsl
ИмяОчереди = "task_queue";
СохранятьОчередь = Истина; // durable
КлиентRMQ.ОбъявитьОчередь(Канал, ИмяОчереди, "", "", СохранятьОчередь);
```

Это изменение необходимо применить как к коду производителя, так и к коду потребителя.

На этом этапе мы уверены, что очередь task_queue не будет потеряна, даже если RabbitMQ перезапустится. Теперь нам нужно пометить наши сообщения как постоянные (persistent):

```bsl
ОтправляемоеСообщение = "Hello World!";
КлючМаршрутизации = ИмяОчереди;
СохранитьСообщениеНаДиске = Истина; // persistent
КлиентRMQ.ОпубликоватьСообщение(
	Канал, 
	ОтправляемоеСообщение, 
	КлючМаршрутизации,
	"",                            // default exchange
	Истина,                        // СериализоватьДанные
	СохранитьСообщениеНаДиске      // persistent
);
```

**Обратите внимание на сохраняемость сообщений:**
Пометка сообщений как сохраняемых не гарантирует, что сообщение не будет потеряно. Несмотря на то, что RabbitMQ сообщает о необходимости сохранения сообщения на диск, все еще существует небольшой промежуток времени, когда RabbitMQ принимает сообщение, но еще не сохраняет его. Кроме того, RabbitMQ не выполняет fsync(2) для каждого сообщения - оно может быть просто сохранено в кэше, а не записано на диск. Гарантии сохраняемости невелики, но этого более чем достаточно для нашей простой очереди задач. Если вам нужна более надежная гарантия, вы можете воспользоваться подтверждением издателя.

## Справедливая отправка
Возможно, вы заметили, что диспетчеризация по-прежнему работает не совсем так, как мы хотим. Например, в ситуации с двумя потребителями, когда все нечетные сообщения являются тяжелыми, а четные - легкими, один потребителями будет постоянно занят, а другой практически не будет выполнять никакой работы. Что ж, RabbitMQ ничего об этом не знает и по-прежнему будет равномерно отправлять сообщения.

Это происходит потому, что RabbitMQ просто отправляет сообщение, когда оно попадает в очередь. Он не учитывает количество неподтвержденных сообщений для пользователя. Он просто отправляет каждое n-е сообщение n-му пользователю вслепую. prefetch = предварительная выборка.



Чтобы обойти это, мы можем использовать метод Channel#basic_qos с параметром prefetch_count=1. При этом используется метод протокола basic.qos, который указывает RabbitMQ не передавать более одного сообщения работнику за раз. Или, другими словами, не отправляйте новое сообщение сотруднику, пока оно не обработает и не подтвердит предыдущее. Вместо этого оно отправит его следующему сотруднику, который еще не занят.

**Настройка QoS (prefetch_count) в 1CRabbitMQ:**

Параметр QoS настраивается при создании канала через третий параметр `КоличествоПредзагруженныхНеПодтвержденныхСообщений`:

```bsl
// Канал с QoS = 1 для справедливого распределения задач
Канал = КлиентRMQ.СоздатьКанал(
    Подключение, 
    Ложь,  // ПодтверждениеПубликацийОтСервера
    1      // КоличествоПредзагруженныхНеПодтвержденныхСообщений = prefetch_count
);
```

Значения параметра:
- `0` (по умолчанию) — без ограничений, сервер отправляет сообщения по циклическому алгоритму
- `1` — справедливое распределение (Fair Dispatch), следующее сообщение отправится только после подтверждения предыдущего
- `> 1` — пакетная обработка, воркер может обрабатывать указанное количество сообщений параллельно
**Обратите внимание на размер очереди:**
Если все работники заняты, ваша очередь может заполниться. Вам следует следить за этим и, возможно, добавить больше работников или использовать TTL сообщения.

TTL сообщений настраивается через свойство `expiration` в структуре свойств сообщения:

```bsl
Свойства = КлиентRMQ.НовыеСвойстваСообщения();
Свойства.expiration = "60000"; // TTL 60 секунд (строка!)
КлиентRMQ.ОпубликоватьСообщение(Канал, Данные, ИмяОчереди, "", Истина, Ложь, Свойства);
```
## Итоговый пример: Надежная рабочая очередь

Используя функции подтверждения сообщений и prefetch_count, вы можете настроить очередь заданий. Параметры долговечности позволяют сохранить выполнение задач даже при перезапуске RabbitMQ.

**Пример производителя (Publisher):**

```bsl
&НаСервере
Процедура ОтправкаЗадач() Экспорт
	
	КлиентRMQ = Обработки.КлиентRMQ.Создать();
	Подключение = КлиентRMQ.ПодключитьсяКСерверу("amqp://guest:guest@localhost:5672/%2f");
	
	Если КлиентRMQ.ЭтоОшибка(Подключение) Тогда
		Возврат;
	КонецЕсли;
	
	Канал = КлиентRMQ.СоздатьКанал(Подключение);
	
	// Durable очередь
	КлиентRMQ.ОбъявитьОчередь(Канал, "task_queue", "", "", Истина);
	
	// Отправка persistent сообщений
	Для Сч = 1 По 10 Цикл
		Сообщение = "Задача номер " + Сч;
		КлиентRMQ.ОпубликоватьСообщение(
			Канал, 
			Сообщение, 
			"task_queue",
			"",
			Истина,      // СериализоватьДанные
			Истина       // СохранитьСообщениеНаДиске (persistent)
		);
		Сообщить("Отправлено: " + Сообщение);
	КонецЦикла;
	
	КлиентRMQ.ОтключитьсяОтСервера(Подключение);
	
КонецПроцедуры
```

**Пример потребителя (Worker):**

```bsl
&НаСервере
Процедура ОбработкаЗадач() Экспорт
	
	КлиентRMQ = Обработки.КлиентRMQ.Создать();
	Подключение = КлиентRMQ.ПодключитьсяКСерверу("amqp://guest:guest@localhost:5672/%2f");
	
	Если КлиентRMQ.ЭтоОшибка(Подключение) Тогда
		Возврат;
	КонецЕсли;
	
	// Канал с QoS = 1 (справедливое распределение)
	Канал = КлиентRMQ.СоздатьКанал(Подключение, Ложь, 1);
	
	// Durable очередь
	КлиентRMQ.ОбъявитьОчередь(Канал, "task_queue", "", "", Истина);
	
	// Получатель с ручным подтверждением
	Получатель = КлиентRMQ.СоздатьПолучателя(Канал, "task_queue", "worker-1", Ложь);
	
	Пока КлиентRMQ.СледующееСообщение(Получатель) Цикл
		ДанныеСообщения = КлиентRMQ.ДанныеСообщения();
		
		Если КлиентRMQ.ЭтоОшибка(ДанныеСообщения) Тогда
			Продолжить;
		КонецЕсли;
		
		Попытка
			Сообщить("Обработка: " + ДанныеСообщения.Данные);
			
			// Имитация работы
			ОбщегоНазначенияБТС.Пауза(5);
			
			// Подтвердить успешную обработку
			КлиентRMQ.ПодтвердитьСообщение(Канал, ДанныеСообщения.Тег);
			Сообщить("Завершено: " + ДанныеСообщения.Данные);
		Исключение
			// При ошибке вернуть в очередь
			КлиентRMQ.ОтклонитьСообщение(Канал, ДанныеСообщения.Тег, Истина);
			ЗаписьЛогаСистемы("RabbitMQ Worker", ОписаниеОшибки());
		КонецПопытки;
	КонецЦикла;
	
	КлиентRMQ.ОтключитьсяОтСервера(Подключение);
	
КонецПроцедуры
```

**Ключевые моменты:**
1. **Durable очередь** (`СохранятьОчередь = Истина`) — переживет перезагрузку сервера
2. **Persistent сообщения** (`СохранитьСообщениеНаДиске = Истина`) — сохранятся на диск
3. **QoS = 1** при создании канала — справедливое распределение задач
4. **Ручное подтверждение** (`no_ack = Ложь`) — гарантия обработки
5. **Обработка ошибок** через `ОтклонитьСообщение` с возвратом в очередь

Теперь мы можем перейти к уроку 3 и узнать, как доставить одно и то же сообщение многим пользователям.


Благодарю за внимание.